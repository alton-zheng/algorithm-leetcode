# 605. 种花的问题

这道题本质上，可以理解为一排花地里是否可以种满所需要种植的花。

下面整理 3 种可行的方法

&nbsp;

## 方法一： 统计连续 0

这个比较好理解， 只有连续 0 的时候才可能种花， 题目所述，花不会连续在相邻的2块地上。

根据题目的要求， 咱们将花种在花坛的某一区域内（因为可能花不够，没涉及的区域可能都是空地，这里先不考虑）,按照最优种花方式4块空地中 $2$ 多花仅有以下 $3$ 中情况： 

- `1010`
- `0101`
- `1001`

其它的所有排列方式，都可以由以上组合而来.有兴趣的朋友，可以自证下。两种花之间的空地数量与能中多少多之间的关系如下： 

咱们来举证下， 当 2 多花之间： 

- 1 块空地， 无解，会违背存在相邻的2 朵花
- 2 块空地， 无解，会违背存在相邻的2 朵花
- 3 块空地， 只有一种解：   e.g. `10001` -> `10101`
- 4 块空地，有 2 中解：e.g. `100001` -> `101001` 或 `100101`
- 5 块空地， 最优解：e.g. `1000001` -> `1010101` ， 发现可以种 2 多花
- 6 块空地， 最优解 2 种：e.g. `10000001`  -> `10101001` 或 `10010101`
- ...

&nbsp;

将规律总结如下： 

- $[1, 2]$ -> $0$
- $[3, 4]$ -> $1$
- $[5, 6]$ -> $2$
- ......
- $[n - 1, n]$ -> $(n - 1) / 2$

> n 为连续 0 数量

&nbsp;

由于花坛左右两边没有可能没有花朵，这种场景下的统计方法与上述规律不同，为啥呢？ 

因为上述规律是在两朵花之间 0 的连续数量才有效。 咱们来模拟下如何解决此场景问题呢？ 

e.g. `00100001` ： 

- index [3, 6] 连续 4 个 $0$， 根据 $[3, 4]$ -> $1$  这个区间可以中一种花，整个花坛: 
  - 由 $00100001$ 变成了  $00101001$ 或者 $00100101$
- 咱们再看前面  $00$ ， 根据题意明显可以种一种花，将花坛变成 $10101001$ 或者 $10100101$
  - 但是大家可以发现它并不符合上述规律 $[3, 4]$ -> $1$ , 为什么呢？ 
  - 因为 `00` 前边并没有花，花会抢水资源。
  - 如何解决呢？ 很简单，为了统一规则前边加 `10`， 后边加 `01`
  - $00100001$ -> $1000100001$ ，这样就不存在两边有空地的场景，全变成了只有花坛中间有空地的情况

&nbsp;

- java 

```java
class java00002.m01.Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {

        int res = 0;
        // 由于花坛 left 加了 花和空地
        // 因此初始空地的个数为 1
        int zero = 1;

        for (int flower: flowerbed) {
            if (flower == 0) {
                zero++;
                continue;
            }

            // 再次遇到 花时，统计可以种的花数量
            res += (zero - 1) / 2;

            // 满足条件，则退出
            if (res >= n) {
                return true;
            }
            zero = 0;
        }

        // 花坛后边加了2块地，空地和花
        zero++;
        res += (zero - 1) / 2;
        return res >= n;

    }
}
```



&nbsp;

## 方法二：种花

由于题目限制，原花坛不存在相邻的两朵花，因此可以用下列方法来种花

白话点，遇到能种花的地就种花，不能种花的地，跳到下一个可能能种花的地。

- 返回 $true$ ，花种完（$n$ = $0$） 
- 返回 $false$, 花未种 ($n$ > 0)

```java
class java00002.m01.Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {

        int len = flowerbed.length;

        for (int i = 0; i < len && n > 0;) {

            if (n == 0) {
                return true;
            }
            // 说明当前地不能种花，调到下一可能能种花的地
            if (flowerbed[i] == 1) {
                i += 2;
                continue;
            }

            // 说明此地能种花，种一朵花（n--）, 跳到下一可能种花的地
            if (i == len - 1 || flowerbed[i + 1] == 0) {
                i += 2;
                n--;
                continue;
            }

            // 当前位置为 0， 下一位置为 1 , 说明当前地不能种花，调到下一可能能种花的地
            i += 3;

        }

        return n <= 0;
    }
}
```

&nbsp;

### 方法三：贪心算法

结合方法二， 不在前后添加花和空地，分 3 中情况来分析，得出结论：

```java
class java00002.m01.Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {

        int flowers = 0;
        int len = flowerbed.length;

        int before = -1;
        for (int i = 0; i < len; i++) {
            if (flowerbed[i] == 1) {
                if (before < 0) {

                    // before < 0 ,意味着当前位置前没有任何花存在， 可以在最右边花左边种植 i / 2 多花
                    flowers += i / 2;
                } else {
                    // 最多可以在2多花中间范围内种植 (i − before −2)/2 朵花
                    flowers += (i - before - 2) / 2;
                }
                if (flowers >= n) {
                    return true;
                }
                before = i;
            }
        }

        if (before < 0) {

            // 如果花坛上没有任何花朵，则有 m 个位置可以种植花，最多可以种植 (len + 1) / 2 朵花。
            flowers += (len + 1) / 2;

        } else {

            // 下标 before 右边有 len − before − 1 个位置，可以种植花的位置数是 len − before − 2，最多可以种植 (len − before − 1) / 2 朵花
            flowers += (len - before - 1) / 2;

        }

        // 当 flowers 大于等于题目的 n, 则返回 true, 否则返回 false
        return flowers >= n;
    }
}
```

